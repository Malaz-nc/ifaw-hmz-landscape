<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFAW - Elephant Corridors in the Greater Hwange Landscape</title>
    <link rel="icon" href="images/favicon.ico" type="image/x-icon">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Leaflet Fullscreen CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.fullscreen/2.0.0/Control.FullScreen.css" />
    
    <!-- Leaflet MarkerCluster CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.css" />
    
    <!-- Custom CSS -->
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/style-update.css">
    
    <style>
        /* Additional styles to match the reference map */
        #sidebar {
            width: 250px;
        }
        
        .sidebar-title {
            background-color: #3373b4;
        }
        
        .control-section h3 {
            color: #3373b4;
        }
        
        /* Error notification */
        .error-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ff5555;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            font-size: 14px;
            max-width: 80%;
            text-align: center;
        }
        
        /* Success notification */
        .success-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            font-size: 14px;
            max-width: 80%;
            text-align: center;
        }
        
        /* Feature labels */
        .towns-label div, 
        .places-label div,
        .matetsiunits-label div {
            background: rgba(255, 255, 255, 0.8) !important;
            padding: 3px 6px !important;
            border-radius: 3px !important;
            font-weight: bold !important;
            font-size: 12px !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2) !important;
            border: 1px solid rgba(0, 0, 0, 0.2) !important;
            pointer-events: none !important;
        }
    </style>
</head>
<body>
    <div id="header">
        <div class="header-content">
            <img src="images/ifaw.png" alt="IFAW Logo" class="logo">
            <h1>ELEPHANT CORRIDORS IN THE GREATER HWANGE LANDSCAPE</h1>
            <div class="north-arrow-container">
                <img src="images/north-arrow.svg" alt="North Arrow" class="north-arrow">
            </div>
        </div>
    </div>
    
    <div id="main-container">
        <div id="map"></div>
        
        <div id="sidebar">
            <h2 class="sidebar-title">Map Controls</h2>
            
            <div class="control-section">
                <h3>Basemaps</h3>
                <div class="control-items">
                    <label><input type="radio" name="basemap" value="OpenStreetMap" checked> OpenStreetMap</label>
                    <label><input type="radio" name="basemap" value="Satellite"> Satellite</label>
                    <label><input type="radio" name="basemap" value="Topographic"> Topographic</label>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Land Types</h3>
                <div class="control-items">
                    <label><input type="checkbox" class="layer-control" data-layer="landuse" checked> Land Use</label>
                    <label><input type="checkbox" class="layer-control" data-layer="communityCa" checked> Community Conservation Areas</label>
                    <label><input type="checkbox" class="layer-control" data-layer="matetsiunits" checked> Matetsi Safari Area</label>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Administrative</h3>
                <div class="control-items">
                    <label><input type="checkbox" class="layer-control" data-layer="landscapeboundary" checked> Landscape Boundary</label>
                    <label><input type="checkbox" class="layer-control" data-layer="districtboundaries" checked> District Boundaries</label>
                    <label><input type="checkbox" class="layer-control" data-layer="bufferwards" checked> IFAW Operating Wards</label>
                </div>
            </div>
            
            <div class="control-section">
                <h3>IFAW Activity Areas</h3>
                <div class="control-items">
                    <label><input type="checkbox" class="layer-control" data-layer="projectsites" checked> Project Sites</label>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Features</h3>
                <div class="control-items">
                    <label><input type="checkbox" class="layer-control" data-layer="wildlife_corridors" checked> Wildlife Corridors</label>
                    <label><input type="checkbox" class="layer-control" data-layer="rivers" checked> Rivers</label>
                    <label><input type="checkbox" class="layer-control" data-layer="watersources" checked> Water Sources</label>
                    <label><input type="checkbox" class="layer-control" data-layer="roads" checked> Roads</label>
                    <label><input type="checkbox" class="layer-control" data-layer="places" checked> Places</label>
                    <label><input type="checkbox" class="layer-control" data-layer="towns" checked> Towns</label>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Legend</h3>
                <div id="legend-content"></div>
            </div>
            
            <div class="control-section">
                <h3>Analysis</h3>
                <div id="analysis-content">
                    <p class="analysis-item">Total Area: <span id="total-area">Loading...</span></p>
                    <p class="analysis-item">Corridor Length: <span id="corridor-length">Loading...</span></p>
                    <p class="analysis-item">Towns Count: <span id="towns-count">Loading...</span></p>
                </div>
            </div>
            
            <div class="sidebar-footer">
                <p>Created by IFAW © 2025</p>
            </div>
        </div>
    </div>
    
    <div id="info-panel" class="hidden">
        <div class="info-header">
            <h3>Feature Information</h3>
            <button class="close-btn">&times;</button>
        </div>
        <div id="info-content"></div>
    </div>
    
    <div id="footer">
        <p>Map Data: OpenStreetMap and contributors, CC-BY-SA | IFAW © 2025</p>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Leaflet Fullscreen JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.fullscreen/2.0.0/Control.FullScreen.js"></script>
    
    <!-- Leaflet MarkerCluster JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.js"></script>
    
    <!-- Leaflet-Polyline-Decorator for animated arrows -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.6.0/leaflet.polylineDecorator.min.js"></script>
    
    <!-- Turf.js for spatial analysis -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    
    <!-- Custom JS - load in correct order -->
    <script src="js/config.js"></script>
    <script src="js/map.js"></script>
    
    <!-- Define the fixMapIssues function here to ensure it's available -->
    <script>
        // Calculate length of a LineString or MultiLineString feature in kilometers
        function calculateLength(feature) {
            if (!feature || !feature.geometry || (feature.geometry.type !== 'LineString' && feature.geometry.type !== 'MultiLineString')) {
                return 0;
            }
            
            let length = 0;
            
            try {
                if (feature.geometry.type === 'LineString') {
                    const line = feature.geometry.coordinates;
                    for (let i = 1; i < line.length; i++) {
                        const p1 = L.latLng(line[i-1][1], line[i-1][0]);
                        const p2 = L.latLng(line[i][1], line[i][0]);
                        length += p1.distanceTo(p2) / 1000; // Convert meters to kilometers
                    }
                } else if (feature.geometry.type === 'MultiLineString') {
                    feature.geometry.coordinates.forEach(line => {
                        for (let i = 1; i < line.length; i++) {
                            const p1 = L.latLng(line[i-1][1], line[i-1][0]);
                            const p2 = L.latLng(line[i][1], line[i][0]);
                            length += p1.distanceTo(p2) / 1000; // Convert meters to kilometers
                        }
                    });
                }
            } catch (error) {
                console.error('Error calculating length:', error);
                length = 0;
            }
            
            return length;
        }

        // Calculate area of a polygon feature in square kilometers
        function calculateArea(feature) {
            if (!feature || !feature.geometry || (feature.geometry.type !== 'Polygon' && feature.geometry.type !== 'MultiPolygon')) {
                return 0;
            }
            
            let area = 0;
            
            try {
                if (window.turf) {
                    area = turf.area(feature) / 1000000; // Convert square meters to square kilometers
                } else {
                    // Very basic fallback if turf.js is not available
                    // This will be less accurate
                    if (feature.geometry.type === 'Polygon') {
                        // Approximate with a simple algorithm
                        area = 0; // Simplified - would need a proper algorithm here
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        // Sum the areas of each polygon
                        area = 0; // Simplified - would need a proper algorithm here
                    }
                }
            } catch (error) {
                console.error('Error calculating area:', error);
                area = 0;
            }
            
            return area;
        }

        // Helper function to show success notification
        function showSuccessNotification(message) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'success-notification';
            notification.textContent = message;
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.left = '50%';
            notification.style.transform = 'translateX(-50%)';
            notification.style.backgroundColor = '#4CAF50';
            notification.style.color = 'white';
            notification.style.padding = '10px 15px';
            notification.style.borderRadius = '4px';
            notification.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
            notification.style.zIndex = '10000';
            notification.style.maxWidth = '80%';
            notification.style.textAlign = 'center';
            notification.style.fontSize = '14px';
            
            // Add close button
            const closeBtn = document.createElement('span');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.marginLeft = '10px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.fontWeight = 'bold';
            closeBtn.style.fontSize = '18px';
            closeBtn.addEventListener('click', function() {
                document.body.removeChild(notification);
            });
            
            notification.appendChild(closeBtn);
            
            // Add to body
            document.body.appendChild(notification);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 5000);
        }

        // Helper function to show error notification
        function showErrorNotification(message) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'error-notification';
            notification.textContent = message;
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.left = '50%';
            notification.style.transform = 'translateX(-50%)';
            notification.style.backgroundColor = '#ff5555';
            notification.style.color = 'white';
            notification.style.padding = '10px 15px';
            notification.style.borderRadius = '4px';
            notification.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
            notification.style.zIndex = '10000';
            notification.style.maxWidth = '80%';
            notification.style.textAlign = 'center';
            notification.style.fontSize = '14px';
            
            // Add close button
            const closeBtn = document.createElement('span');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.marginLeft = '10px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.fontWeight = 'bold';
            closeBtn.style.fontSize = '18px';
            closeBtn.addEventListener('click', function() {
                document.body.removeChild(notification);
            });
            
            notification.appendChild(closeBtn);
            
            // Add to body
            document.body.appendChild(notification);
            
            // Auto-remove after 8 seconds
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 8000);
        }

        // Bind popup to feature
        function bindPopupToFeature(feature, layer) {
            if (feature.properties) {
                let popupContent = "<div class='feature-popup'>";
                for (const key in feature.properties) {
                    popupContent += `<p><strong>${key}:</strong> ${feature.properties[key]}</p>`;
                }
                popupContent += "</div>";
                layer.bindPopup(popupContent);
            }
        }

        // Fix map issues function
        function fixMapIssues() {
            console.log("Fixing map issues...");
            
            // Fix file paths for GeoJSON layers
            const filePathFixes = {
                'landuse': 'landuse.geojson',
                'districtboundaries': 'Districtboundaries.geojson',
                'communityCa': 'communityCA.geojson',
                'matetsiunits': 'matetsiunits.geojson'
            };
            
            // Try to load or reload problematic layers
            for (const [layerId, filePath] of Object.entries(filePathFixes)) {
                if (typeof allLayers === 'undefined' || !allLayers[layerId]) {
                    loadLayer(layerId, filePath);
                }
            }
            
            // Update analysis content with real data
            updateAnalysisContent();
            
            window.fixesApplied = true;
            console.log("Map fixes applied successfully!");
        }
        
        // Load a layer
        function loadLayer(layerId, filePath) {
            console.log(`Attempting to load layer: ${layerId} from data/${filePath}`);
            
            fetch(`data/${filePath}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to load ${layerId} (${response.status}): ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log(`Successfully loaded ${layerId} data`);
                    
                    // Create layer based on type
                    const layerStyle = getStyleForLayer(layerId);
                    let layer;
                    
                    if (['places', 'towns', 'watersources'].includes(layerId)) {
                        // Point layers
                        layer = L.geoJSON(data, {
                            pointToLayer: function(feature, latlng) {
                                return L.circleMarker(latlng, layerStyle);
                            },
                            onEachFeature: function(feature, layer) {
                                bindPopupToFeature(feature, layer);
                            }
                        });
                    } else {
                        // Polygon or line layers
                        layer = L.geoJSON(data, {
                            style: function() {
                                return layerStyle;
                            },
                            onEachFeature: function(feature, layer) {
                                bindPopupToFeature(feature, layer);
                            }
                        });
                    }
                    
                    // Add layer to map and store in allLayers
                    if (typeof map !== 'undefined') {
                        layer.addTo(map);
                        
                        if (typeof window.allLayers === 'undefined') {
                            window.allLayers = {};
                        }
                        
                        window.allLayers[layerId] = layer;
                        console.log(`Added ${layerId} layer to map`);
                        
                        // Check visibility based on checkbox
                        const checkbox = document.querySelector(`.layer-control[data-layer="${layerId}"]`);
                        if (checkbox && !checkbox.checked) {
                            map.removeLayer(layer);
                        }
                    }
                })
                .catch(error => {
                    console.error(`Error loading layer ${layerId}:`, error);
                    showErrorNotification(`Failed to load ${layerId} layer. Check console for details.`);
                });
        }
        
        // Get style for layer
        function getStyleForLayer(layerId) {
            const styleMap = {
                'landuse': {
                    color: '#8BC34A',
                    weight: 1,
                    opacity: 0.7,
                    fillOpacity: 0.3
                },
                'districtboundaries': {
                    color: '#9C27B0',
                    weight: 2,
                    opacity: 0.7,
                    fillOpacity: 0.1
                },
                'communityCa': {
                    color: '#FFEB3B',
                    weight: 1,
                    opacity: 0.8,
                    fillOpacity: 0.3
                },
                'matetsiunits': {
                    color: '#FF9800',
                    weight: 1,
                    opacity: 0.8,
                    fillOpacity: 0.3
                },
                'places': {
                    radius: 5,
                    fillColor: '#9C27B0',
                    color: '#000',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                },
                'towns': {
                    radius: 7,
                    fillColor: '#F44336',
                    color: '#000',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                },
                'watersources': {
                    radius: 6,
                    fillColor: '#03A9F4',
                    color: '#0288D1',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                }
            };
            
            return styleMap[layerId] || {
                color: '#888888',
                weight: 2,
                opacity: 0.7,
                fillOpacity: 0.3
            };
        }
        
        // Update analysis content
        function updateAnalysisContent() {
            console.log("Updating analysis content...");
            
            setTimeout(() => {
                let totalArea = 0;
                let corridorLength = 0;
                let townsCount = 0;
                
                // Calculate total landscape area
                if (allLayers && allLayers.landscapeboundary) {
                    allLayers.landscapeboundary.eachLayer(function(layer) {
                        if (layer.feature) {
                            totalArea += calculateArea(layer.feature);
                        }
                    });
                }
                
                // Calculate corridor length
                if (allLayers && allLayers.wildlife_corridors) {
                    allLayers.wildlife_corridors.eachLayer(function(layer) {
                        if (layer.feature) {
                            corridorLength += calculateLength(layer.feature);
                        }
                    });
                }
                
                // Count towns
                if (allLayers && allLayers.towns) {
                    allLayers.towns.eachLayer(function() {
                        townsCount++;
                    });
                }
                
                // Update the display
                document.getElementById('total-area').textContent = totalArea.toFixed(2) + ' km²';
                document.getElementById('corridor-length').textContent = corridorLength.toFixed(2) + ' km';
                document.getElementById('towns-count').textContent = townsCount;
                
                console.log("Analysis content updated");
            }, 2000); // Give time for layers to load
        }
    </script>
    
    <script>
        // Add a simple debugging utility
        function debugMapState() {
            console.log("DEBUG: Map state");
            console.log("- map object exists:", typeof map !== 'undefined');
            console.log("- CONFIG exists:", typeof CONFIG !== 'undefined');
            console.log("- allLayers count:", Object.keys(allLayers || {}).length);
            
            if (typeof map !== 'undefined') {
                console.log("- map center:", map.getCenter());
                console.log("- map zoom:", map.getZoom());
            }
            
            // Check if files are loaded
            console.log("- config.js loaded:", typeof CONFIG !== 'undefined');
            console.log("- map.js loaded:", typeof initializeMap === 'function');
            console.log("- fixMapIssues defined:", typeof fixMapIssues === 'function');
        }

        // Call the fix function when everything is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Document ready, waiting for map to initialize...");
            
            // Debug after short delay
            setTimeout(debugMapState, 2000);
            
            // Wait to make sure map is initialized
            setTimeout(function() {
                if (typeof fixMapIssues === 'function') {
                    console.log("Applying map fixes...");
                    try {
                        fixMapIssues();
                        showSuccessNotification("Map initialized successfully!");
                    } catch (error) {
                        console.error("Error applying map fixes:", error);
                        showErrorNotification("There was an error initializing the map. Check the console for details.");
                    }
                } else {
                    console.error("fixMapIssues function not found!");
                    debugMapState();
                }
            }, 6000); // Wait 6 seconds to ensure map is fully loaded
        });
    </script>
</body>
</html>